<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A front end siege division built ~"><title>前端知识梳理之HTTP协议 | David's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b5b30c3f05f1d88ff91cf0f233b1fa32';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();

<!-- GrowingIO Analytics code version 2.1 -->
<!-- Copyright 2015-2018 GrowingIO, Inc. More info available at http://www.growingio.com -->
!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");
  gio('init','9a2bc3f2970e279e', {});

//custom page code begin here

//custom page code end here

gio('send');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端知识梳理之HTTP协议</h1><a id="logo" href="/.">David's blog</a><p class="description">Welcome to my den</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端知识梳理之HTTP协议</h1><div class="post-meta">May 25, 2020<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2020/05/25/前端知识梳理之HTTP协议/#vcomment"> </a><div class="post-content"><h3 id="HTTP-的请求方法"><a href="#HTTP-的请求方法" class="headerlink" title="HTTP 的请求方法"></a>HTTP 的请求方法</h3><h4 id="具体有哪些请求方法？"><a href="#具体有哪些请求方法？" class="headerlink" title="具体有哪些请求方法？"></a>具体有哪些请求方法？</h4><p>http/1.1规定了以下请求方法(注意，都是大写):</p>
<ul>
<li>GET: 通常用来获取资源</li>
<li>HEAD: 获取资源的元信息</li>
<li>POST: 提交数据，即上传数据</li>
<li>PUT: 修改数据</li>
<li>DELETE: 删除资源(几乎用不到)</li>
<li>CONNECT: 建立连接隧道，用于代理服务器</li>
<li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li>
<li>TRACE: 追踪请求-响应的传输路径</li>
</ul>
<h4 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h4><p>首先最直观的是语义上的区别。</p>
<p>而后又有这样一些具体的差别:</p>
<ul>
<li>从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>
<li>从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)</li>
<li>从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>
<h3 id="如何理解-URI？"><a href="#如何理解-URI？" class="headerlink" title="如何理解 URI？"></a>如何理解 URI？</h3><p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。</p>
<p>但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p>
<h4 id="URI-的结构"><a href="#URI-的结构" class="headerlink" title="URI 的结构"></a>URI 的结构</h4><p>URI 真正最完整的结构是这样的。<br><img src="/img/uri.png" class="[class names]" title="[width] [height] [title text [alt text]]"></p>
<p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p>
<p>scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。</p>
<p>user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p>
<p>host:port表示主机名和端口。</p>
<p>path表示请求路径，标记资源所在位置。</p>
<p>query表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。</p>
<p>fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</p>
<p>举个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.baidu.com/s?wd=HTTP&amp;rsv_spt=1</span></span><br></pre></td></tr></table></figure></p>
<p>这个 URI 中，https即scheme部分，<a href="http://www.baidu.com为host:port部分（注意，http" target="_blank" rel="noopener">www.baidu.com为host:port部分（注意，http</a> 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&amp;rsv_spt=1就是query部分。</p>
<h4 id="URI-编码"><a href="#URI-编码" class="headerlink" title="URI 编码"></a>URI 编码</h4><p>URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p>
<p>因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。</p>
<p>如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。</p>
<h3 id="如何理解-HTTP-状态码？"><a href="#如何理解-HTTP-状态码？" class="headerlink" title="如何理解 HTTP 状态码？"></a>如何理解 HTTP 状态码？</h3><p>RFC 规定 HTTP 的状态码为三位数，被分为五类:</p>
<ul>
<li>1xx: 表示目前是协议处理的中间状态，还需要后续操作。</li>
<li>2xx: 表示成功状态。</li>
<li>3xx: 重定向状态，资源位置发生变动，需要重新请求。</li>
<li>4xx: 请求报文有误。</li>
<li>5xx: 服务器端发生错误。<br>接下来就一一分析这里面具体的状态码。<h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。</li>
</ul>
<h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>200 OK是见得最多的成功状态码。通常在响应体中放有数据。</p>
<p>204 No Content含义与 200 相同，但响应头后没有 body 数据。</p>
<p>206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断电续传，当然也会带上相应的响应头字段Content-Range。</p>
<h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。</p>
<p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p>
<p>而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。</p>
<p>304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存</p>
<h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p>
<p>401 Unauthorized 代表客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</p>
<p>403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p>
<p>404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。</p>
<p>405 Method Not Allowed: 请求方法不被服务器端允许。</p>
<p>406 Not Acceptable: 资源无法满足客户端的条件。</p>
<p>408 Request Timeout: 服务器等待了太长时间。</p>
<p>409 Conflict: 多个请求发生了冲突。</p>
<p>413 Request Entity Too Large: 请求体的数据过大。</p>
<p>414 Request-URI Too Long: 请求行里的 URI 太大。</p>
<p>429 Too Many Request: 客户端发送的请求过多。</p>
<p>431 Request Header Fields Too Large请求头的字段内容太大。</p>
<h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p>
<p>501 Not Implemented: 表示客户端请求的功能还不支持。</p>
<p>502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p>
<p>503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。</p>
<h3 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h3><h4 id="HTTP-的特点概括如下"><a href="#HTTP-的特点概括如下" class="headerlink" title="HTTP 的特点概括如下:"></a>HTTP 的特点概括如下:</h4><ul>
<li><p>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p>
</li>
<li><p>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p>
</li>
<li><p>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p>
</li>
<li><p>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p>
</li>
</ul>
<h4 id="HTTP-缺点"><a href="#HTTP-缺点" class="headerlink" title="HTTP 缺点"></a>HTTP 缺点</h4><h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。</p>
<p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p>
<p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p>
<h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p>
<p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p>
<h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p>
<h3 id="对-Content-系列字段了解多少？"><a href="#对-Content-系列字段了解多少？" class="headerlink" title="对 Content 系列字段了解多少？"></a>对 Content 系列字段了解多少？</h3><p>对于Content系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。</p>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p>
<p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p>
<p>答案是肯定的。不过首先需要介绍一个标准——MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p>
<p>因此，HTTP 从MIME type取了一部分来标记报文 body 部分的数据类型，这些类型体现在Content-Type这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用Accept字段。</p>
<p>具体而言，这两个字段的取值可以分为下面几类:</p>
<ul>
<li>text： text/html, text/plain, text/css 等</li>
<li>image: image/gif, image/jpeg, image/png 等</li>
<li>audio/video: audio/mpeg, video/mp4 等</li>
<li>application: application/json, application/javascript, application/pdf, application/octet-stream</li>
</ul>
<h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的Content-Encoding字段上， 同样的，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。这个字段的取值有下面几种：</p>
<ul>
<li>gzip: 当今最流行的压缩格式</li>
<li>deflate: 另外一种著名的压缩格式</li>
<li>br: 一种专门为 HTTP 发明的压缩算法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Encoding: gizp</span><br></pre></td></tr></table></figure>
<h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>对于发送方而言，还有一个Content-Language字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为Accept-Language。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Language: zh-CN, zh, en</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Language: zh-CN, zh, en</span><br></pre></td></tr></table></figure>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>最后是一个比较特殊的字段, 在接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，相信大家也经常看到，以charset属性指定。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">Accept-Charset: charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
<h4 id="对于定长和不定长的数据，HTTP-是怎么传输的？"><a href="#对于定长和不定长的数据，HTTP-是怎么传输的？" class="headerlink" title="对于定长和不定长的数据，HTTP 是怎么传输的？"></a>对于定长和不定长的数据，HTTP 是怎么传输的？</h4><h5 id="定长包体"><a href="#定长包体" class="headerlink" title="定长包体"></a>定长包体</h5><p>对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。</p>
<p>我们用一个nodejs服务器来模拟一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Length'</span>, <span class="number">10</span>);</span><br><span class="line">    res.write(<span class="string">"helloworld"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"成功启动"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>启动后访问: localhost:8081。</p>
<p>浏览器中显示如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br></pre></td></tr></table></figure></p>
<p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p>
<p>我们试着把这个长度设置的小一些:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Content-Length'</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure></p>
<p>重启服务，再次访问，现在浏览器中内容如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hellowor</span><br></pre></td></tr></table></figure>
<p>那后面的ld哪里去了呢？实际上在 http 的响应体中直接被截去了。</p>
<p>然后我们试着将这个长度设置得大一些:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Content-Length'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p>
<p>此时浏览器会显示 网页无法正常运作, 可以看到Content-Length对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p>
<h5 id="不定长包体"><a href="#不定长包体" class="headerlink" title="不定长包体"></a>不定长包体</h5><p>上述是针对于定长包体，那么对于不定长包体而言是如何传输的呢？</p>
<p>这里就必须介绍另外一个 http 头部字段了:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p>
<ul>
<li>Content-Length 字段会被忽略</li>
<li>基于长连接持续推送动态内容<br>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf8'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Length'</span>, <span class="number">10</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Transfer-Encoding'</span>, <span class="string">'chunked'</span>);</span><br><span class="line">    res.write(<span class="string">"&lt;p&gt;来啦&lt;/p&gt;"</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">"第一次传输&lt;br/&gt;"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      res.write(<span class="string">"第二次传输"</span>);</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8009</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"成功启动"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>访问效果 会依次 按照 在页面 输出 res.write 的内容. </p>
<h3 id="HTTP-中如何处理表单数据的提交"><a href="#HTTP-中如何处理表单数据的提交" class="headerlink" title="HTTP 中如何处理表单数据的提交?"></a>HTTP 中如何处理表单数据的提交?</h3><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:</p>
<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data<br>由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中。</li>
</ul>
<h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><ul>
<li>其中的数据会被编码成以&amp;分隔的键值对</li>
<li>字符以URL编码方式编码。<br>如：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换过程: &#123;a: 1, b: 2&#125; -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)</span></span><br><span class="line"><span class="string">"a%3D1%26b%3D2"</span></span><br></pre></td></tr></table></figure>
<h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><ul>
<li>请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=—-WebkitFormBoundaryRRJKeWfHPGrS4LKe。</li>
<li>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上–表示结束。</li>
</ul>
<p>相应的请求体是下面这样:</p>
<p>Content-Disposition: form-data;name=”data1”;<br>Content-Type: text/plain<br>data1<br>—-WebkitFormBoundaryRRJKeWfHPGrS4LKe<br>Content-Disposition: form-data;name=”data2”;<br>Content-Type: text/plain<br>data2<br>—-WebkitFormBoundaryRRJKeWfHPGrS4LKe–</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>值得一提的是，multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工》&gt;具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。而且，在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更&gt;多的空间。</p>
</blockquote>
<h3 id="如何解决-HTTP-的队头阻塞问题？"><a href="#如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="如何解决 HTTP 的队头阻塞问题？"></a>如何解决 HTTP 的队头阻塞问题？</h3><h4 id="什么是-HTTP-队头阻塞？"><a href="#什么是-HTTP-队头阻塞？" class="headerlink" title="什么是 HTTP 队头阻塞？"></a>什么是 HTTP 队头阻塞？</h4><p>从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。</p>
<h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p>
<p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p>
<h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p>
<p>比如 content1.baidu.com 、content2.baidu.com。</p>
<p>这样一个baidu.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p>
<h3 id="对-Cookie-了解多少？"><a href="#对-Cookie-了解多少？" class="headerlink" title="对 Cookie 了解多少？"></a>对 Cookie 了解多少？</h3><h4 id="Cookie-简介"><a href="#Cookie-简介" class="headerlink" title="Cookie 简介"></a>Cookie 简介</h4><p>前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？</p>
<p>HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。举例如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头</span></span><br><span class="line">Cookie: a=xxx;b=xxx</span><br><span class="line"><span class="comment">// 响应头</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: a=xxx</span><br><span class="line"><span class="keyword">set</span>-Cookie: b=xxx</span><br></pre></td></tr></table></figure></p>
<h4 id="Cookie-属性"><a href="#Cookie-属性" class="headerlink" title="Cookie 属性"></a>Cookie 属性</h4><h5 id="生存周期"><a href="#生存周期" class="headerlink" title="生存周期"></a>生存周期</h5><p>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。</p>
<ul>
<li>Expires即过期时间</li>
<li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。<br>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>关于作用域也有两个属性: Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。</p>
<h4 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h4><p>如果 cookie 字段带上HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p>
<p>相应的，对于 CSRF 攻击的预防，也有SameSite属性。</p>
<p>SameSite可以设置为三个值，Strict、Lax和None。</p>
<p>a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求baidu.com网站只能在baidu.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</p>
<p>b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</p>
<p>c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。</p>
<h4 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h4><ul>
<li><p>容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p>
</li>
<li><p>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。</p>
</li>
<li><p>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p>
</li>
</ul>
<h3 id="如何理解-HTTP-代理？"><a href="#如何理解-HTTP-代理？" class="headerlink" title="如何理解 HTTP 代理？"></a>如何理解 HTTP 代理？</h3><p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。</p>
<p>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。</p>
<p>那代理服务器到底是用来做什么的呢? </p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li><p><b>负载均衡。</b>客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</p>
</li>
<li><p><b>保障安全。</b>利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</p>
</li>
<li><p><b>缓存代理。</b>将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</p>
</li>
</ul>
<h3 id="如何理解-HTTP-缓存及缓存代理？"><a href="#如何理解-HTTP-缓存及缓存代理？" class="headerlink" title="如何理解 HTTP 缓存及缓存代理？"></a>如何理解 HTTP 缓存及缓存代理？</h3><p>关于强缓存和协商缓存的内容，我已经在能不能说一说浏览器缓存做了详细分析，小结如下:</p>
<p>首先通过 Cache-Control 验证强缓存是否可用</p>
<ul>
<li>如果强缓存可用，直接使用</li>
<li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新<ul>
<li>若资源更新，返回资源和200状态码</li>
<li>否则，返回304，告诉浏览器直接从缓存获取资源<br>这一节我们主要来说说另外一种缓存方式: 代理缓存。</li>
</ul>
</li>
</ul>
<h4 id="为什么产生代理缓存？"><a href="#为什么产生代理缓存？" class="headerlink" title="为什么产生代理缓存？"></a>为什么产生代理缓存？</h4><p>对于源服务器来说，它也是有缓存的，比如Redis, Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p>
<p>由此引入了缓存代理的机制。让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p>
<p>那缓存代理究竟是如何做到的呢？</p>
<p>总的来说，缓存代理的控制分为两部分，一部分是源服务器端的控制，一部分是客户端的控制。</p>
<h4 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="headerlink" title="源服务器的缓存控制"></a>源服务器的缓存控制</h4><h5 id="private-和-public"><a href="#private-和-public" class="headerlink" title="private 和 public"></a>private 和 public</h5><p>在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入private或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。</p>
<p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的Cache-Control设为private，而不是public。</p>
<h5 id="proxy-revalidate"><a href="#proxy-revalidate" class="headerlink" title="proxy-revalidate"></a>proxy-revalidate</h5><p>must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取。</p>
<h5 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h5><p>s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突。</p>
<p>讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public, max-age=<span class="number">1000</span>, s-maxage=<span class="number">2000</span></span><br></pre></td></tr></table></figure>
<p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p>
<h4 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="headerlink" title="客户端的缓存控制"></a>客户端的缓存控制</h4><h5 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="headerlink" title="max-stale 和 min-fresh"></a>max-stale 和 min-fresh</h5><p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-stale: 5</span><br></pre></td></tr></table></figure>
<p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在5秒之内，还是可以从代理中获取的。</p>
<p>又比如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min-fresh: 5</span><br></pre></td></tr></table></figure>
<p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。</p>
<h4 id="only-if-cached"><a href="#only-if-cached" class="headerlink" title="only-if-cached"></a>only-if-cached</h4><p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504（Gateway Timeout）。</p>
<p>以上便是缓存代理的内容，涉及的字段比较多，希望能多多回顾，加深理解。</p>
<h3 id="什么是跨域？浏览器如何拦截响应？如何解决？"><a href="#什么是跨域？浏览器如何拦截响应？如何解决？" class="headerlink" title="什么是跨域？浏览器如何拦截响应？如何解决？"></a>什么是跨域？浏览器如何拦截响应？如何解决？</h3><p>在前后端分离的开发模式中，经常会遇到跨域问题，即 Ajax 请求发出去了，服务器也成功响应了，前端就是拿不到这个响应。接下来我们就来好好讨论一下这个问题。</p>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>浏览器遵循同源政策(scheme(协议)、host(主机)和port(端口)都相同则为同源)。非同源站点有这样一些限制:</p>
<ul>
<li>不能读取和修改对方的 DOM</li>
<li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li>
<li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li>
</ul>
<p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为跨域请求。</p>
<p>跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。</p>
<p>接下来我们来说一说解决跨域问题的几种方案。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 其实是 W3C 的一个标准，全称是跨域资源共享。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: 简单请求和非简单请求。</p>
<p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于简单请求:</p>
<p>请求方法为 GET、POST 或者 HEAD<br>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)<br>浏览器画了这样一个圈，在这个圈里面的就是简单请求, 圈外面的就是非简单请求，然后针对这两种不同的请求进行不同的处理。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>请求发出去之前，浏览器做了什么？</p>
<p>它会自动在请求头当中，添加一个Origin字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，如果Origin不在这个字段的范围中，那么浏览器就会将响应拦截。</p>
<p>因此，Access-Control-Allow-Origin字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p>
<p>Access-Control-Allow-Credentials。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>Access-Control-Expose-Headers。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: aaa</span><br></pre></td></tr></table></figure>
<p>那么在前端可以通过 XMLHttpRequest.getResponseHeader(‘aaa’) 拿到 aaa 这个字段的值。</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求相对而言会有些不同，体现在两个方面: 预检请求和响应字段。</p>
<p>我们以 PUT 方法为例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://xxx.com'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'xxx'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>当这段代码执行后，首先会发送预检请求。这个预检请求的请求行和请求体是下面这个格式:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS / HTTP/1.1</span><br><span class="line">Origin: 当前地址</span><br><span class="line">Host: xxx.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>
<p>预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p>
<ul>
<li>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法</li>
<li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li>
</ul>
<p>这是预检请求。接下来是响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。</p>
<p>预检请求的响应。如下面的格式:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure></p>
<p>其中有这样几个关键的响应头字段:</p>
<ul>
<li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。</li>
<li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li>
<li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li>
<li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li>
<li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。<br>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。</li>
</ul>
<p>CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsonp = <span class="function">(<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> generateURL = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataStr = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      dataStr += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;dataStr&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化回调函数名称</span></span><br><span class="line">    callbackName = callbackName || <span class="built_in">Math</span>.random().toString.replace(<span class="string">','</span>, <span class="string">''</span>); </span><br><span class="line">    <span class="comment">// 创建 script 元素并加入到当前文档中</span></span><br><span class="line">    <span class="keyword">let</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    scriptEle.src = generateURL();</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    <span class="comment">// 绑定到 window 上，为了后面调用</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="comment">// script 执行完了，成为无用元素，需要清除</span></span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然在服务端也会有响应的操作, 以 express 为例:</p>
<p>let express = require(‘express’)<br>let app = express()<br>app.get(‘/‘, function(req, res) {<br>  let { a, b, callback } = req.query<br>  console.log(a); // 1<br>  console.log(b); // 2<br>  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行<br>  res.end(<code>${callback}(&#39;数据包&#39;)</code>);<br>})<br>app.listen(3000)</p>
<p>前端这样简单地调用一下就好了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  params: &#123; </span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到数据进行处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 数据包</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>和CORS相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。</p>
<p>what？反向代理？我给你看一张图你就懂了。<br><img src="/img/proxy.png" class="[class names]" title="[width] [height] [title text [alt text]]"></p>
<p>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。</p>
<p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的负载均衡，换句话说，反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。</p>
<p>因此，两者的区别就很明显了，正向代理服务器是帮客户端做事情，而反向代理服务器是帮其它的服务器做事情。</p>
<p>好了，那 Nginx 是如何来解决跨域的呢？</p>
<p>比如说现在客户端的域名为client.com，服务器的域名为server.com，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  <span class="number">80</span>;</span><br><span class="line">  server_name  client.com;</span><br><span class="line">  location /api &#123;</span><br><span class="line">    proxy_pass server.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是client.com，让客户端首先访问 client.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给server.com，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpeg&amp;WeChatQR=null&amp;GitHub=https://github.com/DavidYuanX&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/前端知识梳理/">前端知识梳理</a></div><div class="post-nav"><a class="pre" href="/2020/06/10/前端知识梳理之性能优化/">前端知识梳理之性能优化</a><a class="next" href="/2020/05/20/前端知识梳理之安全篇/">前端知识梳理之安全篇</a></div><div id="vcomment"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><script>const waline = Waline.init({
  el: '#vcomment',
  path: decodeURI(location.pathname) || '/',
  lang: 'zh-cn',
  serverURL: 'https://vercel-xi-gilt.vercel.app',
  pageSize:'10'
});</script></div></div></div><aside class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input class="popup-trigger" placeholder="Search" readonly="readonly"></div></div><div class="toc-article" id="toc"><div class="toc-title">Categories<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-的请求方法"><span class="toc-number">1.</span> <span class="toc-text">HTTP 的请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#具体有哪些请求方法？"><span class="toc-number">1.1.</span> <span class="toc-text">具体有哪些请求方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GET-和-POST-有什么区别？"><span class="toc-number">1.2.</span> <span class="toc-text">GET 和 POST 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解-URI？"><span class="toc-number">2.</span> <span class="toc-text">如何理解 URI？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URI-的结构"><span class="toc-number">2.1.</span> <span class="toc-text">URI 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URI-编码"><span class="toc-number">2.2.</span> <span class="toc-text">URI 编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解-HTTP-状态码？"><span class="toc-number">3.</span> <span class="toc-text">如何理解 HTTP 状态码？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1xx"><span class="toc-number">3.1.</span> <span class="toc-text">1xx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2xx"><span class="toc-number">3.2.</span> <span class="toc-text">2xx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3xx"><span class="toc-number">3.3.</span> <span class="toc-text">3xx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4xx"><span class="toc-number">3.4.</span> <span class="toc-text">4xx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5xx"><span class="toc-number">3.5.</span> <span class="toc-text">5xx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><span class="toc-number">4.</span> <span class="toc-text">简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-的特点概括如下"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP 的特点概括如下:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-缺点"><span class="toc-number">4.2.</span> <span class="toc-text">HTTP 缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#无状态"><span class="toc-number">4.2.1.</span> <span class="toc-text">无状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#明文传输"><span class="toc-number">4.3.</span> <span class="toc-text">明文传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#队头阻塞问题"><span class="toc-number">4.4.</span> <span class="toc-text">队头阻塞问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对-Content-系列字段了解多少？"><span class="toc-number">5.</span> <span class="toc-text">对 Content 系列字段了解多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据格式"><span class="toc-number">5.1.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#压缩方式"><span class="toc-number">5.2.</span> <span class="toc-text">压缩方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持语言"><span class="toc-number">5.3.</span> <span class="toc-text">支持语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符集"><span class="toc-number">5.4.</span> <span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对于定长和不定长的数据，HTTP-是怎么传输的？"><span class="toc-number">5.5.</span> <span class="toc-text">对于定长和不定长的数据，HTTP 是怎么传输的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定长包体"><span class="toc-number">5.5.1.</span> <span class="toc-text">定长包体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不定长包体"><span class="toc-number">5.5.2.</span> <span class="toc-text">不定长包体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-中如何处理表单数据的提交"><span class="toc-number">6.</span> <span class="toc-text">HTTP 中如何处理表单数据的提交?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#application-x-www-form-urlencoded"><span class="toc-number">6.1.</span> <span class="toc-text">application/x-www-form-urlencoded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multipart-form-data"><span class="toc-number">6.2.</span> <span class="toc-text">multipart/form-data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">6.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决-HTTP-的队头阻塞问题？"><span class="toc-number">7.</span> <span class="toc-text">如何解决 HTTP 的队头阻塞问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-HTTP-队头阻塞？"><span class="toc-number">7.1.</span> <span class="toc-text">什么是 HTTP 队头阻塞？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发连接"><span class="toc-number">7.2.</span> <span class="toc-text">并发连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#域名分片"><span class="toc-number">7.3.</span> <span class="toc-text">域名分片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对-Cookie-了解多少？"><span class="toc-number">8.</span> <span class="toc-text">对 Cookie 了解多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-简介"><span class="toc-number">8.1.</span> <span class="toc-text">Cookie 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-属性"><span class="toc-number">8.2.</span> <span class="toc-text">Cookie 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生存周期"><span class="toc-number">8.2.1.</span> <span class="toc-text">生存周期</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域"><span class="toc-number">8.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安全相关"><span class="toc-number">8.4.</span> <span class="toc-text">安全相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie-的缺点"><span class="toc-number">8.5.</span> <span class="toc-text">Cookie 的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解-HTTP-代理？"><span class="toc-number">9.</span> <span class="toc-text">如何理解 HTTP 代理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#功能"><span class="toc-number">9.1.</span> <span class="toc-text">功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解-HTTP-缓存及缓存代理？"><span class="toc-number">10.</span> <span class="toc-text">如何理解 HTTP 缓存及缓存代理？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么产生代理缓存？"><span class="toc-number">10.1.</span> <span class="toc-text">为什么产生代理缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源服务器的缓存控制"><span class="toc-number">10.2.</span> <span class="toc-text">源服务器的缓存控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#private-和-public"><span class="toc-number">10.2.1.</span> <span class="toc-text">private 和 public</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proxy-revalidate"><span class="toc-number">10.2.2.</span> <span class="toc-text">proxy-revalidate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#s-maxage"><span class="toc-number">10.2.3.</span> <span class="toc-text">s-maxage</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端的缓存控制"><span class="toc-number">10.3.</span> <span class="toc-text">客户端的缓存控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#max-stale-和-min-fresh"><span class="toc-number">10.3.1.</span> <span class="toc-text">max-stale 和 min-fresh</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#only-if-cached"><span class="toc-number">10.4.</span> <span class="toc-text">only-if-cached</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是跨域？浏览器如何拦截响应？如何解决？"><span class="toc-number">11.</span> <span class="toc-text">什么是跨域？浏览器如何拦截响应？如何解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是跨域"><span class="toc-number">11.1.</span> <span class="toc-text">什么是跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">11.2.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单请求"><span class="toc-number">11.3.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非简单请求"><span class="toc-number">11.4.</span> <span class="toc-text">非简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">11.5.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx"><span class="toc-number">11.6.</span> <span class="toc-text">Nginx</span></a></li></ol></li></ol></div></div></div></aside><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">David's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_site_pv"></span> times</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/underscore-min.js"></script><script type="text/javascript" src="/js/inView.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>