<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A front end siege division built ~"><title>前端知识梳理之JS基础篇 | David's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b5b30c3f05f1d88ff91cf0f233b1fa32';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();

<!-- GrowingIO Analytics code version 2.1 -->
<!-- Copyright 2015-2018 GrowingIO, Inc. More info available at http://www.growingio.com -->
!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");
  gio('init','9a2bc3f2970e279e', {});

//custom page code begin here

//custom page code end here

gio('send');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端知识梳理之JS基础篇</h1><a id="logo" href="/.">David's blog</a><p class="description">Welcome to my den</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端知识梳理之JS基础篇</h1><div class="post-meta">Feb 8, 2020<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2020/02/08/前端知识梳理之JS基础篇/#vcomment"> </a><div class="post-content"><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><h4 id="JS原始数据类型有哪些？引用数据类型有哪些？"><a href="#JS原始数据类型有哪些？引用数据类型有哪些？" class="headerlink" title="JS原始数据类型有哪些？引用数据类型有哪些？"></a>JS原始数据类型有哪些？引用数据类型有哪些？</h4><p>在 JS 中，存在着 6 种原始值，分别是：</p>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
</ul>
<p>引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</p>
<h4 id="说出下面运行的结果，解释原因。"><a href="#说出下面运行的结果，解释原因。" class="headerlink" title="说出下面运行的结果，解释原因。"></a>说出下面运行的结果，解释原因。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.age = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">'hzj'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">'fyq'</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// -&gt; ?</span></span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// -&gt; ?</span></span><br></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1：&#123;<span class="attr">name</span>: “fyq”, <span class="attr">age</span>: <span class="number">26</span>&#125;</span><br><span class="line">p2：&#123;<span class="attr">name</span>: “hzj”, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，相当于传引用. 所以通过调用person.age = 26 改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p>
</blockquote>
<h4 id="null究竟是不是对象"><a href="#null究竟是不是对象" class="headerlink" title="null究竟是不是对象?"></a>null究竟是不是对象?</h4><p>null 不是对象,虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object。为了避免这种问题，我们可以通过 Object.prototype.toString.call(xx)进行判断类型。</p>
<h4 id="‘1’-toString-为什么可以调用？"><a href="#‘1’-toString-为什么可以调用？" class="headerlink" title="‘1’.toString()为什么可以调用？"></a>‘1’.toString()为什么可以调用？</h4><p>其实在这个语句运行的过程中做了这样几件事情：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'1'</span>);</span><br><span class="line">s.toString();</span><br><span class="line">s = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>第一步: 创建String类实例。</p>
<p>第二步: 调用实例方法。</p>
<p>第三步: 执行完方法立即销毁这个实例。</p>
<p>整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。</p>
<h4 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h4><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<h3 id="数据类型如何检测"><a href="#数据类型如何检测" class="headerlink" title="数据类型如何检测"></a>数据类型如何检测</h3><h4 id="typeof-方法判断类型"><a href="#typeof-方法判断类型" class="headerlink" title="typeof 方法判断类型"></a>typeof 方法判断类型</h4><p>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure></p>
<p>但对于引用数据类型，除了函数之外，都会显示”object”。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof [] // 'object'</span><br><span class="line">typeof &#123;&#125; // 'object'</span><br><span class="line">typeof console.log // 'function'</span><br></pre></td></tr></table></figure>
<p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">'hello world'</span></span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="能不能手动实现一下instanceof的功能"><a href="#能不能手动实现一下instanceof的功能" class="headerlink" title="能不能手动实现一下instanceof的功能"></a>能不能手动实现一下instanceof的功能</h4><p>能, 从原型链查找 是否匹配 ,代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//基本数据类型直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">'object'</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//查找到尽头，还没找到</span></span><br><span class="line">        <span class="keyword">if</span>(proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到相同的原型对象</span></span><br><span class="line">        <span class="keyword">if</span>(proto == right.prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeof(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="string">"111"</span>, <span class="built_in">String</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(myInstanceof(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"111"</span>), <span class="built_in">String</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Object-is和-的区别"><a href="#Object-is和-的区别" class="headerlink" title="Object.is和===的区别"></a>Object.is和===的区别</h4><p>目前发现的 是 Object 相较于 === 严格一些, 修正了一些特殊情况下的失误. 目前发现有 +0和-0，NaN和NaN。</p>
<p>源码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// SameValue algorithm</span></span><br><span class="line">   <span class="keyword">if</span> (x === y) &#123; <span class="comment">// Steps 1-5, 7-10</span></span><br><span class="line">     <span class="comment">// Steps 6.b-6.e: +0 != -0</span></span><br><span class="line">     <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Step 6.a: NaN == NaN</span></span><br><span class="line">     <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="JS数据类型之隐式转换"><a href="#JS数据类型之隐式转换" class="headerlink" title="JS数据类型之隐式转换"></a>JS数据类型之隐式转换</h3><h4 id="发生了一些什么"><a href="#发生了一些什么" class="headerlink" title="[] == ![] 发生了一些什么?"></a>[] == ![] 发生了一些什么?</h4><p>首先 == 运算符，会将左右两边都需要转换为数字然后进行比较。</p>
<p>[]转换为数字为0。<br>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true, 因此![]为false，进而在转换成数字，变为0。</p>
<p>0 == 0 ， 结果为true</p>
<h4 id="JS中类型转换有哪几种？"><a href="#JS中类型转换有哪几种？" class="headerlink" title="JS中类型转换有哪几种？"></a>JS中类型转换有哪几种？</h4><p>JS中，类型转换只有三种：</p>
<ul>
<li>转换成数字</li>
<li>转换成布尔值</li>
<li>转换成字符串<br>转换具体规则如下:</li>
</ul>
<img src="/img/translation_table.jpg" class="[class names]" title="[width] [height] [title text [alt text]]">
<h4 id="和-有什么区别？"><a href="#和-有什么区别？" class="headerlink" title="== 和 ===有什么区别？"></a>== 和 ===有什么区别？</h4><p>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’===1的结果是false，因为一边是string，另一边是number。</p>
<p>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</p>
<ul>
<li>两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false</li>
<li>判断的是否是null和undefined，是的话就返回true</li>
<li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li>
<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>
<li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="literal">true</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="string">"[object Object]"</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="对象转原始类型是根据什么流程运行的？"><a href="#对象转原始类型是根据什么流程运行的？" class="headerlink" title="对象转原始类型是根据什么流程运行的？"></a>对象转原始类型是根据什么流程运行的？</h4><p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<ul>
<li>如果Symbol.toPrimitive()方法，优先调用再返回</li>
<li>调用valueOf()，如果转换为原始类型，则返回</li>
<li>调用toString()，如果转换为原始类型，则返回</li>
<li>如果都没有返回原始类型，会报错</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  value: 3,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 4;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return '5'</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj + 1); // 输出7</span><br></pre></td></tr></table></figure>
<h4 id="如何让if-a-1-amp-amp-a-2-条件成立？"><a href="#如何让if-a-1-amp-amp-a-2-条件成立？" class="headerlink" title="如何让if(a == 1 &amp;&amp; a == 2)条件成立？"></a>如何让if(a == 1 &amp;&amp; a == 2)条件成立？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  value: 0,</span><br><span class="line">  valueOf: function() &#123;</span><br><span class="line">    this.value++;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2);//true</span><br></pre></td></tr></table></figure>
<p>可以发现 可以用上题 中的特性来解题</p>
<h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>闭包是指有权访问另外一个函数作用域中的变量的函数，创建闭包的常见方式,就是在一个函数内部创建另一个函数.且由于闭包会携带包含它的函数的作用域,过度使用会导致占用更多的内存.因此需谨慎使用闭包.</p>
</blockquote>
<h4 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    var a = 3;</span><br><span class="line">    console.log(a);//3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！<br>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(a);//2</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var x = f1();</span><br><span class="line">x();</span><br></pre></td></tr></table></figure>
<p>这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。</p>
<p>那是不是只有返回函数才算是产生了闭包呢？、</p>
<p>回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f3;</span><br><span class="line">function f1() &#123;</span><br><span class="line">  var a = 2</span><br><span class="line">  f3 = function() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure></p>
<p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。</p>
<p>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p>
<h4 id="闭包的运用"><a href="#闭包的运用" class="headerlink" title="闭包的运用"></a>闭包的运用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i <span class="tag">&lt;<span class="name">=</span> <span class="attr">5</span>; <span class="attr">i</span> ++)&#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">setTimeout</span>(<span class="attr">function</span> <span class="attr">timer</span>()&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">console.log</span>(<span class="attr">i</span>)</span></span><br><span class="line"><span class="tag">  &#125;, <span class="attr">0</span>)</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这是一道很经典的 Es5 运用闭包 保存变量,当然 Es6 中针对这一点出现了革命性的变化 ,let 标签,让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。 代码的作用域以块级为单位。代码如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 1; i <span class="tag">&lt;<span class="name">=</span> <span class="attr">5</span>; <span class="attr">i</span>++)&#123;</span></span><br><span class="line"><span class="tag">  <span class="attr">setTimeout</span>(<span class="attr">function</span> <span class="attr">timer</span>()&#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">console.log</span>(<span class="attr">i</span>)</span></span><br><span class="line"><span class="tag">  &#125;,<span class="attr">0</span>)</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="js原型链"><a href="#js原型链" class="headerlink" title="js原型链"></a>js原型链</h3><h4 id="原型对象和构造函数是什么"><a href="#原型对象和构造函数是什么" class="headerlink" title="原型对象和构造函数是什么?"></a>原型对象和构造函数是什么?</h4><p>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。</p>
<p>当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个<strong>proto</strong>属性，指向构造函数的原型对象。</p>
<h4 id="原型链-是什么"><a href="#原型链-是什么" class="headerlink" title="原型链 是什么?"></a>原型链 是什么?</h4><p>JavaScript对象通过prototype指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p>
<ul>
<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>
<li>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</li>
</ul>
<h3 id="js-继承"><a href="#js-继承" class="headerlink" title="js 继承"></a>js 继承</h3><h4 id="第一种-借助call"><a href="#第一种-借助call" class="headerlink" title="第一种: 借助call"></a>第一种: 借助call</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Parent1()&#123;</span><br><span class="line">   this.name = 'parent1';</span><br><span class="line"> &#125;</span><br><span class="line"> function Child1()&#123;</span><br><span class="line">   Parent1.call(this);</span><br><span class="line">   this.type = 'child1'</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(new Child1);</span><br></pre></td></tr></table></figure>
<p>  这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<h4 id="第二种-借助原型链"><a href="#第二种-借助原型链" class="headerlink" title="第二种: 借助原型链"></a>第二种: 借助原型链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'parent2'</span>;</span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'child2'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child2.prototype = <span class="keyword">new</span> Parent2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child2());</span><br></pre></td></tr></table></figure>
<p>看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2();</span><br><span class="line">s1.play.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1.play, s2.play);</span><br></pre></td></tr></table></figure>
<p>可以看到控制台：s1 和 s2 都被改变了. 明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。<br>那么如何规避 这个问题呢? </p>
<h3 id="第三种：将前两种组合"><a href="#第三种：将前两种组合" class="headerlink" title="第三种：将前两种组合"></a>第三种：将前两种组合</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'parent3'</span>;</span><br><span class="line">   <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent3.call(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.type = <span class="string">'child3'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child3.prototype = <span class="keyword">new</span> Parent3();</span><br><span class="line"> <span class="keyword">var</span> s3 = <span class="keyword">new</span> Child3();</span><br><span class="line"> <span class="keyword">var</span> s4 = <span class="keyword">new</span> Child3();</span><br><span class="line"> s3.play.push(<span class="number">4</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(s3.play, s4.play);</span><br></pre></td></tr></table></figure>
<p>可以在控制台看到 之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？</p>
<h4 id="第四种-组合继承的优化1"><a href="#第四种-组合继承的优化1" class="headerlink" title="第四种: 组合继承的优化1"></a>第四种: 组合继承的优化1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'parent4'</span>;</span><br><span class="line">   <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent4.call(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.type = <span class="string">'child4'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child4.prototype = Parent4.prototype;</span><br></pre></td></tr></table></figure>
<p>  这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> Child4();</span><br><span class="line"><span class="built_in">console</span>.log(s3)</span><br></pre></td></tr></table></figure></p>
<p>可以从控制台看到 子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。</p>
<h4 id="第五种-最推荐使用-组合继承的优化1"><a href="#第五种-最推荐使用-组合继承的优化1" class="headerlink" title="第五种(最推荐使用): 组合继承的优化1"></a>第五种(最推荐使用): 组合继承的优化1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">'parent5'</span>;</span><br><span class="line">   <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Child5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   Parent5.call(<span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">this</span>.type = <span class="string">'child5'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> Child5.prototype = <span class="built_in">Object</span>.create(Parent5.prototype);</span><br><span class="line"> Child5.prototype.constructor = Child5;</span><br></pre></td></tr></table></figure>
<p>这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。</p>
<h4 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h4><p>假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  drive()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"wuwuwu!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  music()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"lalala!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  addOil()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哦哟！"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">otherCar</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以实现车的功能，并且以此去扩展不同的车。</p>
<p>但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。</p>
<p>如果让新能源汽车的类继承Car的话，也是有问题的，俗称”大猩猩和香蕉”的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。</p>
<blockquote>
<p>继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。</p>
</blockquote>
<p>当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。</p>
<p>那如何来解决继承的诸多问题呢？</p>
<p>用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。</p>
<p>顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"wuwuwu!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">music</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"lalala!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOil</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"哦哟！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = compose(drive, music, addOil);</span><br><span class="line"><span class="keyword">let</span> newEnergyCar = compose(drive, music);</span><br></pre></td></tr></table></figure></p>
<p>代码干净，复用性也很好。这就是面向组合的设计方式。</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpeg&amp;WeChatQR=null&amp;GitHub=https://github.com/DavidYuanX&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/前端知识梳理/">前端知识梳理</a></div><div class="post-nav"><a class="pre" href="/2020/02/15/前端知识梳理之JS数组篇/">前端知识梳理之JS数组篇</a><a class="next" href="/2020/02/05/前端知识梳理之CSS/">前端知识梳理之CSS</a></div><div id="vcomment"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><script>const waline = Waline.init({
  el: '#vcomment',
  path: decodeURI(location.pathname) || '/',
  lang: 'zh-cn',
  serverURL: 'https://vercel-xi-gilt.vercel.app',
  pageSize:'10'
});</script></div></div></div><aside class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input class="popup-trigger" placeholder="Search" readonly="readonly"></div></div><div class="toc-article" id="toc"><div class="toc-title">Categories<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS数据类型"><span class="toc-number">1.</span> <span class="toc-text">JS数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS原始数据类型有哪些？引用数据类型有哪些？"><span class="toc-number">1.1.</span> <span class="toc-text">JS原始数据类型有哪些？引用数据类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说出下面运行的结果，解释原因。"><span class="toc-number">1.2.</span> <span class="toc-text">说出下面运行的结果，解释原因。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null究竟是不是对象"><span class="toc-number">1.3.</span> <span class="toc-text">null究竟是不是对象?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#‘1’-toString-为什么可以调用？"><span class="toc-number">1.4.</span> <span class="toc-text">‘1’.toString()为什么可以调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1-0-2为什么不等于0-3？"><span class="toc-number">1.5.</span> <span class="toc-text">0.1+0.2为什么不等于0.3？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型如何检测"><span class="toc-number">2.</span> <span class="toc-text">数据类型如何检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-方法判断类型"><span class="toc-number">2.1.</span> <span class="toc-text">typeof 方法判断类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#能不能手动实现一下instanceof的功能"><span class="toc-number">2.2.</span> <span class="toc-text">能不能手动实现一下instanceof的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-is和-的区别"><span class="toc-number">2.3.</span> <span class="toc-text">Object.is和===的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS数据类型之隐式转换"><span class="toc-number">3.</span> <span class="toc-text">JS数据类型之隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发生了一些什么"><span class="toc-number">3.1.</span> <span class="toc-text">[] == ![] 发生了一些什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS中类型转换有哪几种？"><span class="toc-number">3.2.</span> <span class="toc-text">JS中类型转换有哪几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和-有什么区别？"><span class="toc-number">3.3.</span> <span class="toc-text">== 和 ===有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象转原始类型是根据什么流程运行的？"><span class="toc-number">3.4.</span> <span class="toc-text">对象转原始类型是根据什么流程运行的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何让if-a-1-amp-amp-a-2-条件成立？"><span class="toc-number">3.5.</span> <span class="toc-text">如何让if(a == 1 &amp;&amp; a == 2)条件成立？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包的理解"><span class="toc-number">4.</span> <span class="toc-text">闭包的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义"><span class="toc-number">4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的本质"><span class="toc-number">4.2.</span> <span class="toc-text">闭包的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的运用"><span class="toc-number">4.3.</span> <span class="toc-text">闭包的运用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js原型链"><span class="toc-number">5.</span> <span class="toc-text">js原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型对象和构造函数是什么"><span class="toc-number">5.1.</span> <span class="toc-text">原型对象和构造函数是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链-是什么"><span class="toc-number">5.2.</span> <span class="toc-text">原型链 是什么?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js-继承"><span class="toc-number">6.</span> <span class="toc-text">js 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一种-借助call"><span class="toc-number">6.1.</span> <span class="toc-text">第一种: 借助call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二种-借助原型链"><span class="toc-number">6.2.</span> <span class="toc-text">第二种: 借助原型链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三种：将前两种组合"><span class="toc-number">7.</span> <span class="toc-text">第三种：将前两种组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第四种-组合继承的优化1"><span class="toc-number">7.1.</span> <span class="toc-text">第四种: 组合继承的优化1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第五种-最推荐使用-组合继承的优化1"><span class="toc-number">7.2.</span> <span class="toc-text">第五种(最推荐使用): 组合继承的优化1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承的问题"><span class="toc-number">7.3.</span> <span class="toc-text">继承的问题</span></a></li></ol></li></ol></div></div></div></aside><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">David's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_site_pv"></span> times</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/underscore-min.js"></script><script type="text/javascript" src="/js/inView.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>