<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="A front end siege division built ~"><title>前端知识梳理之性能优化 | David's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b5b30c3f05f1d88ff91cf0f233b1fa32';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();

<!-- GrowingIO Analytics code version 2.1 -->
<!-- Copyright 2015-2018 GrowingIO, Inc. More info available at http://www.growingio.com -->
!function(e,t,n,g,i){e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},n=t.createElement("script"),tag=t.getElementsByTagName("script")[0],n.async=1,n.src=('https:'==document.location.protocol?'https://':'http://')+g,tag.parentNode.insertBefore(n,tag)}(window,document,"script","assets.giocdn.com/2.1/gio.js","gio");
  gio('init','9a2bc3f2970e279e', {});

//custom page code begin here

//custom page code end here

gio('send');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端知识梳理之性能优化</h1><a id="logo" href="/.">David's blog</a><p class="description">Welcome to my den</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端知识梳理之性能优化</h1><div class="post-meta">Jun 10, 2020<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a class="disqus-comment-count" href="/2020/06/10/前端知识梳理之性能优化/#vcomment"> </a><div class="post-content"><h3 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h3><p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
<li>缓存位置</li>
</ul>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。</p>
<p>首先是检查强缓存，这个阶段不需要发送HTTP请求。</p>
<p>如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。</p>
<p>在HTTP/1.0和HTTP/1.1当中，这个字段是不一样的。在早期，也就是HTTP/1.0时期，使用的是Expires，而HTTP/1.1使用的是Cache-Control。让我们首先来看看Expires。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Nov <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure></p>
<p>表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。</p>
<p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>在HTTP1.1中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于</p>
<p>它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。比如这个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure></p>
<p>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</p>
<p>如果你觉得它只有max-age一个属性的话，那就大错特错了。</p>
<p>它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: public: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</p>
<p><b>private：</b> 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</p>
<p><b>no-cache: </b>跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。</p>
<p><b>no-store：</b>非常粗暴，不进行任何形式的缓存。</p>
<p><b>s-maxage：</b>这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</p>
<p><b>must-revalidate:</b> 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。</p>
<p>值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。</p>
<p>当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——协商缓存了。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。</p>
<p>具体来说，这样的缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。</p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p>
<p>浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:</p>
<ul>
<li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。</p>
<p>浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:</p>
<p>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。<br>否则返回304，告诉浏览器直接用缓存。</p>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p> 在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</p>
<ul>
<li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li>
<li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>
</ul>
<p>在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。<br>另外，如果两种方式都支持的话，服务器会优先考虑ETag</p>
<h4 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h4><p>前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p>
<p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p>
<p>Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。</p>
<h4 id="Memory-Cache-和-Disk-Cache"><a href="#Memory-Cache-和-Disk-Cache" class="headerlink" title="Memory Cache 和 Disk Cache"></a>Memory Cache 和 Disk Cache</h4><p>Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>
<p>Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p>
<p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<p>这里就不一一展开了, 可以多多回顾, 温故知新. </p>
<h3 id="浏览器的本地存储"><a href="#浏览器的本地存储" class="headerlink" title="浏览器的本地存储?"></a>浏览器的本地存储?</h3><blockquote>
<p>浏览器的本地存储主要分为Cookie、WebStorage和IndexDB, 其中WebStorage又可以分为localStorage和sessionStorage。接下来我们就来一一分析这些本地存储方案。</p>
</blockquote>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。</p>
<p>HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？</p>
<p>这种背景下，就产生了 Cookie.</p>
<p>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p>
<p>Cookie 的作用很好理解，就是用来做状态存储的，但它也是有诸多致命的缺陷的：</p>
<ul>
<li><p>容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p>
</li>
<li><p>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</p>
</li>
<li><p>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p>
</li>
</ul>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。</p>
<p>不过它相对Cookie还是有相当多的区别的:</p>
<ul>
<li><p>容量。localStorage 的容量上限为5M，相比于Cookie的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。</p>
</li>
<li><p>只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。</p>
</li>
<li><p>接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便。</p>
</li>
</ul>
<h5 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h5><p>接下来我们来具体看看如何来操作localStorage。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">"sanyuan"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line">localStorage.setItem(<span class="string">"name"</span>, <span class="string">"sanyuan"</span>); </span><br><span class="line">localStorage.setItem(<span class="string">"info"</span>, <span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure>
<p>接着进入相同的域名时就能拿到相应的值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = localStorage.getItem(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">"info"</span>));</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象。</p>
<h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6><p>利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此利用localStorage .</p>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>sessionStorage以下方面和localStorage一致:</p>
<ul>
<li>容量。容量上限也为 5M。</li>
<li>只存在客户端，默认不参与与服务端的通信。</li>
<li>接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样。<br>但sessionStorage和localStorage有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分sessionStorage就不复存在了。</li>
</ul>
<h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。</li>
<li>可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博就采取了这样的存储方式。</li>
</ul>
<h4 id="IndexDB"><a href="#IndexDB" class="headerlink" title="IndexDB"></a>IndexDB</h4><p>IndexDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p>
<p>关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB" title="[external] [title]" target="_blank" rel="noopener">使用文档</a>。</p>
<p>接着我们来分析一下IndexDB的一些重要特性，除了拥有数据库本身的特性，比如支持事务，存储二进制数据，还有这样一些特性需要格外注意：</p>
<ul>
<li>键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。</li>
<li>异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。</li>
<li>受同源策略限制，即无法访问跨域的数据库。</li>
</ul>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>节流的核心思想: 如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器任务。这就好比公交车，10 分钟一趟，10 分钟内有多少人在公交站等我不管，10 分钟一到我就要发车走人</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> funtion(...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="comment">// 还没到时间</span></span><br><span class="line">    <span class="keyword">if</span>(now - last &lt; interval) <span class="keyword">return</span>;</span><br><span class="line">    last = now;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>核心思想: 每次事件触发则删除原来的定时器，建立新的定时器。跟王者荣耀的回城功能类似，你反复触发回城功能，那么只认最后一次，从最后一次触发开始计时。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span>(timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双剑合璧——加强版节流"><a href="#双剑合璧——加强版节流" class="headerlink" title="双剑合璧——加强版节流"></a>双剑合璧——加强版节流</h4><p>现在我们可以把防抖和节流放到一起，为什么呢？因为防抖有时候触发的太频繁会导致一次响应都没有，我们希望到了固定的时间必须给用户一个响应，事实上很多前端库就是采取了这样的思路。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(now - last &gt; delay)&#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这个时候表示时间到了，必须给响应</span></span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><h4 id="方案一-clientHeight、scrollTop-和-offsetTop"><a href="#方案一-clientHeight、scrollTop-和-offsetTop" class="headerlink" title="方案一:clientHeight、scrollTop 和 offsetTop"></a>方案一:clientHeight、scrollTop 和 offsetTop</h4><p>首先给图片一个占位资源:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"default.jpg"</span> data-src=<span class="string">"http://www.xxx.com/target.jpg"</span> /&gt;&lt;<span class="regexp">/img&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接着，通过监听 scroll 事件来判断图片是否到达视口:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.document.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;<span class="comment">//计数器，从第一张图片开始计</span></span><br><span class="line"></span><br><span class="line">lazyload();<span class="comment">//首次加载别忘了显示图片</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, lazyload);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;<span class="comment">//视口高度</span></span><br><span class="line">  <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;<span class="comment">//滚动条卷去的高度</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = count; i &lt;num; i++) &#123;</span><br><span class="line">    <span class="comment">// 元素现在已经出现在视口中</span></span><br><span class="line">    <span class="keyword">if</span>(img[i].offsetTop &lt; scrollHeight + viewHeight) &#123;</span><br><span class="line">      <span class="keyword">if</span>(img[i].getAttribute(<span class="string">"src"</span>) !== <span class="string">"default.jpg"</span>) <span class="keyword">continue</span>;</span><br><span class="line">      img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">      count ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，最好对 scroll 事件做节流处理，以免频繁触发:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throttle函数我们上节已经实现</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(lazyload, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>
<h4 id="方案二：getBoundingClientRect"><a href="#方案二：getBoundingClientRect" class="headerlink" title="方案二：getBoundingClientRect"></a>方案二：getBoundingClientRect</h4><p>现在我们用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。</p>
<p>上述的 lazyload 函数改成下面这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = count; i &lt;num; i++) &#123;</span><br><span class="line">    <span class="comment">// 元素现在已经出现在视口中</span></span><br><span class="line">    <span class="keyword">if</span>(img[i].getBoundingClientRect().top &lt; <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">      <span class="keyword">if</span>(img[i].getAttribute(<span class="string">"src"</span>) !== <span class="string">"default.jpg"</span>) <span class="keyword">continue</span>;</span><br><span class="line">      img[i].src = img[i].getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">      count ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方案三-IntersectionObserver"><a href="#方案三-IntersectionObserver" class="headerlink" title="方案三: IntersectionObserver"></a>方案三: IntersectionObserver</h4><p>这是浏览器内置的一个API，实现了监听window的scroll事件、判断是否在视口中以及节流三大功能。</p>
<p>我们来具体试一把：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">changes</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//changes 是被观察的元素集合</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = changes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> change = changes[i];</span><br><span class="line">    <span class="comment">// 通过这个属性判断是否在视口中</span></span><br><span class="line">    <span class="keyword">if</span>(change.isIntersecting) &#123;</span><br><span class="line">      <span class="keyword">const</span> imgElement = change.target;</span><br><span class="line">      imgElement.src = imgElement.getAttribute(<span class="string">"data-src"</span>);</span><br><span class="line">      observer.unobserve(imgElement);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">observer.observe(img);</span><br></pre></td></tr></table></figure></p>
<p>这样就很方便地实现了图片懒加载，当然这个IntersectionObserver也可以用作其他资源的预加载，功能非常强大。</p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpeg&amp;WeChatQR=null&amp;GitHub=https://github.com/DavidYuanX&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/前端知识梳理/">前端知识梳理</a></div><div class="post-nav"><a class="pre" href="/2020/06/20/前端知识梳理之常见手写功能/">前端知识梳理之常见手写功能</a><a class="next" href="/2020/05/25/前端知识梳理之HTTP协议/">前端知识梳理之HTTP协议</a></div><div id="vcomment"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/@waline/client@v2/dist/waline.js"></script><script>const waline = Waline.init({
  el: '#vcomment',
  path: decodeURI(location.pathname) || '/',
  lang: 'zh-cn',
  serverURL: 'https://vercel-xi-gilt.vercel.app',
  pageSize:'10'
});</script></div></div></div><aside class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input class="popup-trigger" placeholder="Search" readonly="readonly"></div></div><div class="toc-article" id="toc"><div class="toc-title">Categories<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前端缓存"><span class="toc-number">1.</span> <span class="toc-text">前端缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#强缓存"><span class="toc-number">1.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Expires"><span class="toc-number">1.2.</span> <span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Control"><span class="toc-number">1.3.</span> <span class="toc-text">Cache-Control</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协商缓存"><span class="toc-number">1.4.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Last-Modified"><span class="toc-number">1.5.</span> <span class="toc-text">Last-Modified</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETag"><span class="toc-number">1.6.</span> <span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两者对比"><span class="toc-number">1.7.</span> <span class="toc-text">两者对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存位置"><span class="toc-number">1.8.</span> <span class="toc-text">缓存位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Service-Worker"><span class="toc-number">1.9.</span> <span class="toc-text">Service Worker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Cache-和-Disk-Cache"><span class="toc-number">1.10.</span> <span class="toc-text">Memory Cache 和 Disk Cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器的本地存储"><span class="toc-number">2.</span> <span class="toc-text">浏览器的本地存储?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-number">2.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localStorage"><span class="toc-number">2.2.</span> <span class="toc-text">localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作方式"><span class="toc-number">2.2.1.</span> <span class="toc-text">操作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#应用场景"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sessionStorage"><span class="toc-number">2.3.</span> <span class="toc-text">sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#特点"><span class="toc-number">2.3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#应用场景-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IndexDB"><span class="toc-number">2.4.</span> <span class="toc-text">IndexDB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防抖和节流"><span class="toc-number">3.</span> <span class="toc-text">防抖和节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#节流"><span class="toc-number">3.1.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#防抖"><span class="toc-number">3.2.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双剑合璧——加强版节流"><span class="toc-number">3.3.</span> <span class="toc-text">双剑合璧——加强版节流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片懒加载"><span class="toc-number">4.</span> <span class="toc-text">图片懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方案一-clientHeight、scrollTop-和-offsetTop"><span class="toc-number">4.1.</span> <span class="toc-text">方案一:clientHeight、scrollTop 和 offsetTop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案二：getBoundingClientRect"><span class="toc-number">4.2.</span> <span class="toc-text">方案二：getBoundingClientRect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案三-IntersectionObserver"><span class="toc-number">4.3.</span> <span class="toc-text">方案三: IntersectionObserver</span></a></li></ol></li></ol></div></div></div></aside><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">David's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_site_pv"></span> times</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/underscore-min.js"></script><script type="text/javascript" src="/js/inView.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>